head	1.5;
access;
symbols;
locks
	baker:1.5; strict;
comment	@-- @;


1.5
date	2008.11.24.02.05.39;	author baker;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.23.01.54.28;	author baker;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.20.18.49.43;	author baker;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.19.14.25.53;	author baker;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.19.12.04.57;	author baker;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@--  $Id: threads.ads,v 1.4 2008/11/23 01:54:28 baker Exp baker $

--  Provides thread abstraction, implementing services typically
--  provided by an operating system to schedule the execution of a
--  thread.

with Virtual_Times; use Virtual_Times;
with Generic_Queues;
with Events;
with Jobs;
--  but *not* Tasks!
--  To avoid mutual dependence, tasks (arrival and workload
--  generation objects) can see the threads (system processes) that
--  they influence, but not vice versa.
package Threads is

   type Thread is limited private;
   type Thread_Ref is access all Thread;

   --------------------------
   --  Scheduling Policies --
   --------------------------

   --  Allow us to define plug-in modules to implement
   --  a variety of per-thread scheduling policies.
   --  Each policy may need policy-specific
   --  per-thread parameters and state information.

   package Scheduling_Parameters is
      --  used to specify scheduling parameters, such as budget
      --  and replenishment periodic for aperiodic servers
      type Object is abstract tagged null record;
   end Scheduling_Parameters;

   type Parameters_Class_Ref is access all
     Scheduling_Parameters.Object'Class;

   package Scheduling_Policies_State is
      --  used to store policy-specific per-thread data
      --  such as budget replenishment info
      type Object is abstract tagged null record;
   end Scheduling_Policies_State;

   type Policy_State_Class_Ref is access all
     Scheduling_Policies_State.Object'Class;

   package Scheduling_Policies is

      type Object is abstract tagged record
         Data : Policy_State_Class_Ref;
         T : Thread_Ref;
      end record;

      procedure Bind_Thread
        (P : in out Object;
         T : Thread_Ref);

      procedure Init
        (P : in out Object) is abstract;
      --  Initializes or resets policy-dependent
      --  per-thread scheduling state

      --  The following are "hooks" that allow
      --  insertion of policy-specific actions
      --  at key points during execution.

      procedure New_Job
        (P : in out Object;
         J : in Jobs.Job);
      --  a thread starts executing a new job.
      --  e.g., with  EDF scheduling, the deadline of
      --  the job determines the thread priority

      procedure Suspend
        (P : in out Object);
      --  a thread has suspended itself.
      --  e.g., with polling server, the thread
      --  gives up its remaining budget

      procedure Unsuspend
        (P : in out Object);
      --  a thread wakes up.
      --  e.g., with an aperiodic server, a job arrives
      --  to an empty server job queue, and the job
      --  resumes contention for execution

      procedure New_Current_Thread
        (P : in out Object);
      --  the thread scheduler has switched threads
      --  e.g., if it switches to the idle thread,
      --  this may be a time to replenish server budgets

      procedure Go
        (P : in out Object);
      --  a thread has resumed execution
      --  e.g., this may be a time to set a timer to
      --  lower the thread priority when it has used
      --  up a chunk of budget

      --  You can count on Current pointing to the
      --  current thread.

      procedure Stop
        (P : in out Object);
      --  a thread has stopped execution
      --  e.g., this may be a time to schedule
      --  a replenishment, and to cancel
      --  a timer that would notify us of budget
      --  exhaustion.

      --  You can count on Current pointing to
      --  the stopped thread and

      procedure Idle
        (P : in out Object);
      --  the system is idle
      --  e.g., this may be a time to do any
      --  early replenishment

   end Scheduling_Policies;

   type Policies_Class_Ref is access all
     Scheduling_Policies.Object'Class;

   -------------------------
   --  Thread operations  --
   -------------------------

   procedure Initialize;  -- of the entire threads world
   --  also call this to reset the threads for a new run;
   --  does not delete any existing threads, but does
   --  reset their internal states

   procedure Bind_Policy
     (T : in out Thread_Ref;
      P : Policies_Class_Ref);

   procedure Schedule;

   function New_Thread
     (Go : Events.Class_Ref;
      Stop : Events.Class_Ref;
      Name : String)
     return Thread_Ref;

   procedure New_Job (T : Thread_Ref;
                      J : Jobs.Job);
   --  tells thread (and its scheduler) that we have
   --  started a new job, and so may need to change
   --  deadline

   procedure Unsuspend (T : Thread_Ref);
   --  tells thread that it should not execute;
   --  the initial thread state is suspended

   procedure Suspend (T : Thread_Ref);

   function Name (T: Thread) return String;

   function Total_Idle_Time return Time;

private

   type Thread is record
      --  scheduling policy plug-ins
      Policy : Policies_Class_Ref;
      Policy_State : Policy_State_Class_Ref;
      --  interface for tasks
      Go : Events.Class_Ref;
      Stop : Events.Class_Ref;
      --  scheduling state:
      Is_Suspended : Boolean;
      --  is logically not ready to run
      --  for example, periodic thread waiting for next period
      Is_Policy_Suspended : Boolean;
      --  the thread may be logically ready to run,
      --  but is suspended by the scheduling policy
      --  e.g., it is out of budget
      Priority : Time;
      --  larger is higher
      Is_In_Ready_Queue : Boolean;  -- actually in queue
      Name : String (1 .. 4);
   end record;

   --  The following are for potential read-access by child
   --  packages

   Last_Idle_Time : Time;
   Current : Thread_Ref;
   Idle_Thread : Thread_Ref := null;
   Total_Idle : Time;

   function ">" (L, R : Thread_Ref) return Boolean;
   package Threads_Queues is new Generic_Queues (Thread_Ref);

   --  Thread queues have numerically smallest priority on top
   --  This works well for EDF and deadline monotonic scheduling

   Ready_Queue : Threads_Queues.Object;

   --  A list of all threads that are policy-suspended

   Policy_Suspended_Queue : Threads_Queues.Object;

   --  A list of all threads known to the system.  Should not
   --  include the idle thread.

   All_Threads : Threads_Queues.Object;

   --  The following are for the use of policies that need to
   --  prevent a thread from running, because it is out of budget,
   --  without actually suspending it.

   procedure Policy_Suspend (T : Thread_Ref);
   procedure Policy_Unsuspend  -- use this one
     (T : Thread_Ref);
   procedure Policy_Unsuspend  -- obsolete
     (T : Thread_Ref;
      New_Priority : Time);

end Threads;


@


1.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: threads.ads,v 1.3 2008/11/20 18:49:43 baker Exp baker $
d201 4
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: threads.ads,v 1.2 2008/11/19 14:25:53 baker Exp baker $
d69 1
a69 1
         J : in Jobs.Job) is abstract;
d75 1
a75 1
        (P : in out Object) is abstract;
d81 1
a81 1
        (P : Object) is abstract;
d88 1
a88 1
        (P : Object) is abstract;
d94 1
a94 1
        (P : in out Object) is abstract;
d100 3
d104 1
a104 1
        (P : in out Object) is abstract;
d109 10
a118 1
      --  exhaustion
d160 1
a160 1
   procedure Set_Debug (Level : Integer);
d172 2
a173 1
      Is_Suspended : Boolean;  -- is logically not ready to run
d175 6
a180 1
      Priority : Time; -- larger is higher
a187 1
   Last_Dispatching_Time : Time;
d211 3
a213 1
   procedure Policy_Unsuspend
@


1.2
log
@*** empty log message ***
@
text
@d1 5
a5 1
--  $Id: threads.ads,v 1.1 2008/11/19 12:04:57 baker Exp baker $
d20 8
a27 2
   --  sub-classes used to parameterize implementation of thread
   --  objects
d30 2
d38 1
a38 1
   package Scheduling_Policies_Data is
d42 1
a42 1
   end Scheduling_Policies_Data;
d44 2
a45 2
   type Policy_Data_Class_Ref is access all
     Scheduling_Policies_Data.Object'Class;
d47 1
a47 2
   --  the following provides call-outs for specific scheduling
   --  policies
d49 4
a52 2
   package Scheduling_Policies is
      type Object is abstract tagged null record;
d54 19
a72 3
      procedure Init (P : in out Object;
                      T : Thread_Ref) is abstract;
      --  must initialize T.Policy_Data
a73 4
      procedure Change_Job
        (P : Object;
         T : Thread_Ref;
         J : in Jobs.Object) is abstract;
d75 5
a79 2
        (P : Object;
         T : Thread_Ref) is abstract;
d81 6
a86 2
        (P : Object;
         T : Thread_Ref) is abstract;
d88 5
a92 2
        (P : Object;
         Notified_Thread : Thread_Ref) is abstract;
d94 6
a99 2
        (P : Object;
         T : Thread_Ref) is abstract;
d101 6
a106 8
        (P : Object;
         T : Thread_Ref) is abstract;

--  move into specific policies, using events?
--      procedure Budget_Replenishment (P : Object;
--                                      T : Thread_Ref) is abstract;
--      procedure Budget_Out (P : Object;
--                            T : Thread_Ref) is abstract;
d113 4
d122 4
d129 2
a130 4
     (Policy : Policies_Class_Ref;
      Parms : Parameters_Class_Ref;
      Go_Event : Events.Class_Ref;
      Stop_Event : Events.Class_Ref;
d134 6
d141 2
a142 1
   --  initial thread state is suspended
d155 1
a155 2
      Policy_Data : Policy_Data_Class_Ref;
      Parms : Parameters_Class_Ref;
d157 2
a158 2
      Go_Event : Events.Class_Ref;
      Stop_Event : Events.Class_Ref;
d167 2
a168 1
   -- the following are for potential read-access by child packages
a173 1
   Last_Priority : Time;
d184 2
a185 2
   --  A list of all threads known to the system.
   --  Should not include the idle thread.
d189 9
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
--  $Id$
a125 1
   Debug_Level : Integer := 0; --  default is no debugging output
@
