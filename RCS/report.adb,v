head	1.4;
access;
symbols;
locks
	baker:1.4; strict;
comment	@-- @;


1.4
date	2008.11.24.16.46.29;	author baker;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.24.02.05.39;	author baker;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.23.21.33.20;	author baker;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.20.18.49.43;	author baker;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@--  $Id: report.adb,v 1.3 2008/11/24 02:05:39 baker Exp 1332

with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Float_Text_IO; use Ada.Float_Text_IO;
with Ada.Numerics.Elementary_Functions;
with Tasks;
with Threads;
with Stats; use Stats;
with Sizes;
with Error_Log; use Error_Log;
with Simulator;
with Virtual_Times; use Virtual_Times;
package body Report is

   File : File_Type;

   --  value reserved to indicate erroneous output

   Erroneous : constant Integer := -99999;

   --  statistics are indexed by type of server

   type Float_Cube is array (Servers) of Float_Table;
   type Int_Table is array (Runs) of Int_Array (Loads);
   type Int_Cube  is array (Servers) of Int_Table;

   --  average response time of aperiodic request
   Avg :  Float_Cube := (others => (others => (others => 0.0)));

   --  standard deviation of response time
   SD :   Float_Cube := (others => (others => (others =>  0.0)));

   --  maximum response time
   Max :  Float_Cube := (others => (others => (others =>  0.0)));

   --  utilization
   Util : Float_Cube := (others => (others => (others =>  0.0)));


   --  time usage break down, indexed by:
   --  1) type of server
   --  2) run (corresponding to periodic load level)
   --  These are used to check consistency of the simulation,
   --  to verify that we have not used more or less time
   --  than should have elapsed on the clock.

   Comptd : Int_Cube := (others => (others => (others =>  0)));
   Missed : Int_Cube := (others => (others => (others =>  0)));

   --  execution time consumed

   Exec :   Int_Cube := (others => (others => (others =>  0)));

   --  constants used to compute various confidence levels

   Z90 : constant:= 1.6449; -- for 90% confidence interval
   Z95 : constant:= 1.9600; -- for 95% confidence interval
   Z99 : constant:= 2.5758; -- for 99% confidence interval

   Tex : File_Type;
   Plot : File_Type;
   Prefix : String := "EDF";

   procedure Collect_Periodic
     (R : Runs;
      L : Loads;
      S : Servers;
      D : Stats.Data) is
   begin
      if D.Missed_Deadlines > 0 then
         Put (Log, "*** missed ");
         Put (Log, D.Missed_Deadlines, 0);
         Put_Line (Log, " deadlines");
         raise Program_Error;
      end if;
      Exec (S)(R)(L) := Exec (S)(R)(L) +
        Integer (D.Total_Exec_Time);
      Missed (S)(R)(L) := Missed (S)(R)(L) + D.Missed_Deadlines;
      pragma Assert (D.Missed_Deadlines = 0);
      pragma Assert (D.Total_Exec_Time > 0);
   end Collect_Periodic;

   procedure Collect_Server
     (R : Runs;
      L : Loads;
      S : Servers;
      D : Stats.Data) is
     use Ada.Numerics.Elementary_Functions;
   begin
      pragma Assert (Simulator.Current_Time >= 1);
      pragma Assert (D.Job_Count >= 1);
      pragma Assert (D.Total_Resp_Time > 0.0);
      Avg (S)(R)(L) :=
        Float (D.Total_Resp_Time) / Float (D.Job_Count);
      Max (S)(R)(L) := Float (D.Max_Resp_Time);
      Exec (S)(R)(L) := Exec (S)(R)(L)
        + Integer (D.Total_Exec_Time);
      Missed (S)(R)(L) := Missed (S)(R)(L) + D.Missed_Deadlines;
      if (D.Job_Count > 0) then
        SD (S)(R)(L) := Sqrt ((D.Total_Sq_Resp_Time -
         (D.Total_Resp_Time**2) / Float (D.Job_Count))/
         Float (D.Job_Count - 1));
      else
        pragma Assert (False);
        SD (S)(R)(L) := float (Erroneous);
      end if;
      Util (S)(R)(L) := Float (D.Total_Exec_Time)
        * 100.00 / Float (Simulator.Current_Time);
      Comptd (S)(R)(L) := Comptd (S)(R)(L) + D.Job_Count;
   end Collect_Server;

   procedure Validate
     (R : Runs;
      L : Loads;
      S : Servers) is
      Idle : Time := Threads.Total_Idle_Time;
      Exe : Time := Time (Exec (S)(R)(L));
      Now : Time := Simulator.Current_Time;
   begin
      if Idle + Exe /= Now then
         Trace (0, "Idle + Exec /= Now");
         Put (Log, " Idle = ");
         Put (Log, Integer (Idle), 0);
         Put (Log, " Exec = ");
         Put (Log, Integer (Exe), 0);
         Put (Log, " Now = ");
         Put (Log, Integer (Now), 0);
         New_Line (Log);
         raise Program_Error;
      end if;
   end Validate;

   function Plot_File_Name (R: Runs; I: IATS) return String is
   begin
     return Prefix & character'val (character'pos ('A') + R - 1) &
            character'val (character'pos ('A') + I - 1);
   end Plot_File_Name;

   procedure Start_Plot
     (I : IATS;
      R : Runs) is
      Filename_Root : constant String :=
        Plot_File_Name (R, I);
   begin
      --  open or create the Plot output file
      begin
         create (Plot, out_file, Filename_Root & ".pts");
      exception when others=>
         open (Plot, out_file, Filename_Root & ".pts");
      end;
   end Start_Plot;

   procedure Put_Plot (F : Float) is
   begin
      if F < 0.0 then
         Put (Plot, Float (Erroneous));
      else
         Put (Plot, F, 4, 3, 0);
     end if;
     Put (Plot, " ");
   end Put_Plot;

   procedure Validate_Plot_Line
     (I : IATS;
      R : Runs;
      L : Loads;
      M : Float) is
      -- check for average response times that are better than M/M/1
   begin
--      for S in Sizes.Servers loop
      for S in BGS .. DSS loop
         if Avg (S)(R)(L) < M then
            Put (Log, Plot_File_Name (R, I));
            Put (Log, " at utilization ");
            Put (Log, Util (Sizes.BGS)(R)(L), 4, 3, 0);
            Put (Log, ' ');
            Put (Log, Sizes.Servers'image (S));
            Put (Log, " response time is below M/M/1 by ");
            Put (Log, M - Avg (S)(R)(L), 2, 2, 0);
            New_line (Log);
         end if;
      end loop;
   end Validate_Plot_Line;

   procedure Put_Plot
     (I : IATS;
      R : Runs;
      L : Loads) is
      IAT :  Float := Interarrival_Times (I);
      AL :  Float := Float (Sizes.U (I)) / 100.0;
      M : Float := -- M/M/1, for full server
         AL * IAT / (1.0 - AL);
      -- M/M/1, relative to server capacity =
      -- S: constant Float := float (EDF_Size (R)(Sizes.PLS));
      -- M: constant Float := S*AL*IAT/ (S-AL*float (Server_Period));
   begin
      --  put line of plot file

      pragma Assert (1.0 - AL > 0.0);
      pragma Assert (IAT > 0.0);
      Validate_Plot_Line (I, R, L, M);
      pragma Assert (AL > 0.0);
      put_Plot (AL);                                  -- 1
      put_Plot (Avg (Sizes.BGS)(R)(L));               -- 3
      put_Plot (Avg (Sizes.PLS)(R)(L));               -- 3
      --  put_Plot (Avg (Sizes.DDS)(R)(L));               -- 4
      pragma Assert (Avg (Sizes.DSS)(R)(L) >= 0.0);
      put_Plot (Avg (Sizes.DSS)(R)(L));               -- 5
      -- put_Plot (Avg (Sizes.DXS)(R)(L));               -- 6
      pragma Assert (M > 0.0);
      put_Plot (M);                                   -- 7
      new_line (Plot);

   end Put_Plot;

   procedure Finish_Plot is
   begin
       Close (Plot);
   end Finish_Plot;

   function Tex_File_Name (I: IATS) return String is
   begin
     return Prefix & character'val (character'pos ('A') + I - 1);
   end Tex_File_Name;

   procedure Start_Tex
     (I : IATS) is
      Filename_Root : constant String :=
        Tex_File_Name (I);
   begin
      --  open or create the LaTeX output file
      begin
         create (Tex, out_file, Filename_Root & ".tex");
      exception when others=>
         open (Tex, out_file, Filename_Root & ".tex");
      end;
      --  put out the Latex table header
      put_line (Tex, "\begin{table}\begin{center}");
      put_line (Tex, "\begin{tabular}{ccr@@{}rr@@{}rr@@{}rr@@{}rr@@{}r}");
      put_line (Tex, "periodic&aperiodic");
      for S in BGS .. DSS loop
         --  ??? suppress output for unused polices?
         Put (Tex, "&\twocol{" & Servers'Image (S) & "}");
      end loop;
      put_line (Tex, "\\[10pt]\hline");
   end Start_Tex;

   procedure Put_Tex (S : Sizes.Servers; R : Runs; L : Loads) is
      F : constant Float := Avg (S)(R)(L);
      use Ada.Numerics.Elementary_Functions;
   begin
      if F > 0.0 then
         pragma Assert (Comptd (S)(R)(L) >= 1);
         put (Tex, " & "); put (Tex, Integer (F), 5); put (Tex, " & $\PM$ ");
         put (Tex, Integer (Z99 * SD (S)(R)(L) /
                              Sqrt (float (Comptd (S)(R)(L)))), 3);
      else
         put (Tex, " & \overload & \overload ");
      end if;
   end Put_Tex;

   procedure Put_Tex
     (I : IATS;
      R : Runs;
      L : Loads) is
   begin

      --  put out section of LaTeX table file

      --  periodic task utilization level for this run
       put (Tex, float (U (R))/100.0, 1, 2, 0);
       put (Tex, " & ");
       --  average aperiodic server utlization level for this run
       put (Tex, Util (Sizes.BGS)(R)(L), 1, 2, 0);
       for S in BGS .. DSS loop
          --  for each server size
          --  put out the results of the experiment
          Put_Tex (S, R, L);
      end loop;
      put (Tex, "\\");
      new_line (Tex);

   end Put_Tex;

   procedure Break_Tex is
   begin
      Put_Line (Tex, "\\");
   end Break_Tex;

   procedure Finish_Tex (I : IATS) is
   begin
       Put (Tex, "\end{tabular}\end{center}");
       Put (Tex, "\caption{EDF response times, mean aperiodic IAT ");
       Put (Tex, Integer (Float (Simulator.Current_Time)
                            / Float (Sizes.Interarrival_Times (I))), 1);
       Put (Tex, ", after ");
       Put (Tex, Integer (Simulator.Current_Time), 1);
       Put_line (Tex, " time units.}");
       Put (Tex, "\label{tab:");
       Put (Tex, character'val (character'pos ('A')+I-1));
       Put_line (Tex, "}\end{table}");
       Close (Tex);
   end Finish_Tex;

end Report;
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 3
--  $Id: report.adb,v 1.2 2008/11/23 21:33:20 baker Exp baker $

--  ???  This is a temporary version, with reduced capability.
a64 6
   function Plot_File_Name (R: Runs; I: IATS) return String is
   begin
     return Prefix & character'val (character'pos ('A') + R - 1) &
            character'val (character'pos ('A') + I - 1);
   end Plot_File_Name;

d134 30
d186 32
a217 3
   procedure Put_Tex (S : Sizes.Servers; R : Runs; L : Loads) is
      F : constant Float := Avg (S)(R)(L);
      use Ada.Numerics.Elementary_Functions;
d219 2
a220 9
      if F > 0.0 then
         pragma Assert (Comptd (S)(R)(L) >= 1);
         put (Tex, " & "); put (Tex, Integer (F), 5); put (Tex, " & $\PM$ ");
         put (Tex, Integer (Z99 * SD (S)(R)(L) /
                              Sqrt (float (Comptd (S)(R)(L)))), 3);
      else
         put (Tex, " & \overload & \overload ");
      end if;
   end Put_Tex;
d222 1
a222 1
   procedure Put_Plot (F : Float) is
d224 2
a225 7
      if F < 0.0 then
         Put (Plot, Float (Erroneous));
      else
         Put (Plot, F, 4, 3, 0);
     end if;
     Put (Plot, " ");
   end Put_Plot;
d227 4
a230 3
   procedure Start (I : IATS;
                    R : Runs) is
      Filename_Root : constant String := Plot_File_Name (R, I);
a237 6
      --  open or create the Plot output file
      begin
         create (Plot, out_file, Filename_Root & ".pts");
      exception when others=>
         open (Plot, out_file, Filename_Root & ".pts");
      end;
a241 1
--      for S in Servers loop
d247 1
a247 1
   end Start;
d249 15
a263 1
   procedure Put
d265 2
a266 1
      R : Runs) is
d271 9
a279 19
      for L in Loads loop
         --  for each aperiodic load level
         begin
             --  periodic task utilization level for this run
             put (Tex, float (U (R))/100.0, 1, 2, 0);
             put (Tex, " & ");
             --  average aperiodic server utlization level for this run
             put (Tex, Util (Sizes.BGS)(R)(L), 1, 2, 0);
--             for S in Servers loop
             for S in BGS .. DSS loop
                --  for each server size
                --  put out the results of the experiment
                Put_Tex (S, R, L);
             end loop;
             put (Tex, "\\");
             new_line (Tex);
          exception
             when others=> put_line (Tex, "exception in output");
          end;
d281 2
a282 1
      put_line (Tex, "\\");
d284 1
a284 1
      --  put line of plot file
d286 4
a289 26
      for L in Loads loop
         declare
           IAT :  Float := Interarrival_Times (I);
           AL :  Float := Float (Sizes.U (I)) / 100.0;
           M : Float := -- M/M/1, for full server
               AL * IAT / (1.0 - AL);
           -- M/M/1, relative to server capacity =
           -- S: constant Float := float (EDF_Size (R)(Sizes.PLS));
           -- M: constant Float := S*AL*IAT/ (S-AL*float (Server_Period));
         begin
            pragma Assert (1.0 - AL > 0.0);
            pragma Assert (IAT > 0.0);
            Validate_Plot_Line (I, R, L, M);
            pragma Assert (AL > 0.0);
            put_Plot (AL);                                  -- 1
            put_Plot (Avg (Sizes.BGS)(R)(L));               -- 3
            put_Plot (Avg (Sizes.PLS)(R)(L));               -- 3
--            put_Plot (Avg (Sizes.DDS)(R)(L));               -- 4
            pragma Assert (Avg (Sizes.DSS)(R)(L) >= 0.0);
            put_Plot (Avg (Sizes.DSS)(R)(L));               -- 5
--            put_Plot (Avg (Sizes.DXS)(R)(L));               -- 6
            pragma Assert (M > 0.0);
            put_Plot (M);                                   -- 7
         end;
         new_line (Plot);
      end loop;
d291 1
a291 4
   end Put;

   procedure Finish (I : IATS;
                     R : Runs) is
d304 1
a304 2
       Close (Plot);
   end Finish;
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: report.adb,v 1.1 2008/11/20 18:49:43 baker Exp baker $
d10 1
d15 1
a49 1
   Reqstd : Int_Cube := (others => (others => (others =>  0)));
d88 2
d99 3
d103 1
a103 1
        Float(D.Total_Resp_Time) / Float (D.Job_Count);
d113 1
d121 22
a142 1
   procedure Check_Validity
d149 2
a150 1
      for S in Sizes.Servers loop
d153 1
a153 1
            Put (Log, ' ');
d157 2
a158 2
            Put (Log, " is below M/M/1 by ");
            Put (Log, M - Avg (S)(R)(L), 2, 3, 0);
d162 1
a162 1
   end Check_Validity;
d169 1
d180 2
a181 2
      if F <= 0.0 then
         Put (Plot, "99999.999");
d208 2
a209 1
      for S in Servers loop
d231 2
a232 1
             for S in Servers loop
d249 3
a251 4
           T : constant Float := Avg (Sizes.BGS)(R)(L);
           IAT : constant Float := Interarrival_Times (I);
           AL : constant Float := Util (Sizes.BGS)(R)(L);
           M : constant Float := -- M/M/1, for full server
d257 4
a260 1
            Check_Validity (I, R, L, M);
d262 1
a262 1
            put_Plot (T);                                   -- 2
d264 2
a265 1
            put_Plot (Avg (Sizes.DDS)(R)(L));               -- 4
d267 2
a268 1
            put_Plot (Avg (Sizes.DXS)(R)(L));               -- 6
a269 5
            put_Plot (Avg (Sizes.PLS)(R)(L)/T);             -- 8
            put_Plot (Avg (Sizes.DDS)(R)(L)/T);             -- 9
            put_Plot (Avg (Sizes.DSS)(R)(L)/T);             -- 10
            put_Plot (Avg (Sizes.DXS)(R)(L)/T);             -- 11
            put_Plot (M/T);                                 -- 12
d282 1
a282 1
                            / Float (Reqstd (Sizes.DXS)(I)(1))), 1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
--  $Id$
d5 4
d10 4
a13 2
with Stats;
with Text_IO; use Text_IO;
d18 35
a52 4
   procedure Put_Task_Name (T : Task_Ref) is
   begin
      Put (File, " " & Name (T));
   end Put_Task_Name;
d54 1
a54 4
   procedure Put_Header is
   begin
      For_Every_Task (Put_Task_Name);
   end Put_Header;
d56 1
a56 10
   procedure Open (Filename_Root : String) is
   begin
      --  open or create the output file
      begin
         create (File, out_file, Filename_Root & ".out");
      exception when others=>
         open (File, out_file, Filename_Root & ".out");
      end;
      Put_Header;
   end Open;
d58 3
a60 4
   procedure Close is
   begin
       Close (File);
   end Close;
d62 3
a64 1
   procedure Put_One (
d66 1
a66 1
   procedure Put is
d68 3
a70 1
   end Put;
d72 5
a76 17
   procedure Query_Tasks (Report : Object) is
      S : State renames Report.State;
      procedure Query_One_Task (Task_Ref : Tasks.Object_Ref) is
         use Ada.Tags;
         use Events;
         P, T : Integer;
      begin
         if Task_Ref'Tag = Aperiodic_Tasks.Object'Tag then
            T := Maximum_Response_Time (Task_Ref);
            P := Period (Task_Ref);
--- ... working here ...
         else
            raise Program_Error;
         end if;
      end Query_One_Task;
      procedure Query_All_Tasks is new
        Task_Sets.For_All (Query_One_Task);
d78 41
a118 4
      Query_All_Tasks (S.Tasks);
   end Query_Tasks;

   procedure Chk (I: IATS; R: Runs; L: Loads; M: Float) is
d122 9
a130 5
         if Avg (S)(R)(L)<M then
            put (Errs, Plot_File_Name (R, I)); put (Errs, ' ');
            put (Errs, Util (Sizes.BGS)(R)(L), 4, 3, 0); put (Errs, ' ');
            put (Errs, Sizes.Servers'image (S));  put (Errs, " is below M/M/1 by ");
            put (Errs, M-Avg (S)(R)(L), 2, 3, 0); new_line (Errs);
d133 1
a133 1
   end Chk;
d135 2
a136 2
   procedure Put_Tex (S: Sizes.Servers; R: Runs; L: Loads) is
      F: constant Float := Avg (S)(R)(L);
d139 1
a139 1
      if F>0.0 then
d141 2
a142 2
         put (Tex, Integer (Z99*SD (S)(R)(L)/Sqrt (float (Comptd (S)(R)(L)))), 3);
    --     put (Tex, Integer (3.0*SD (S)(R)(L)/Sqrt (float (Comptd (S)(R)(L)))), 3);
d148 1
a148 1
   procedure Put_Plot (F: Float) is
d150 4
a153 2
     if F <= 0.0 then put (Plot, "99999.999");
     else put (Plot, F, 4, 3, 0);
d155 1
a155 1
     put (Plot, " ");
d158 30
a187 1
   procedure Put is
d190 1
a190 1
      ---  output to LaTex table file
d192 4
a195 3
      put_line (Tex, "\\ ");
      for J in Loads loop
          begin
d198 6
a203 3
             put (Tex, Util (Sizes.BGS)(R)(J), 1, 2, 0);
             for S in Sizes.Servers loop
                Put_Tex (S, R, J);
d213 1
a213 1
      ---  output to Gnuplot data file
d215 1
a215 1
      for J in Loads loop
d217 5
a221 5
           T: constant Float := Avg (Sizes.BGS)(R)(J);
           IAT: constant Float := Interarrival_Time_Data (I);
           AL: constant Float := Util (Sizes.BGS)(R)(J);
           M: constant Float := -- M/M/1, for full server
               AL*IAT/ (1.0-AL);
d226 1
a226 1
            Chk (I, R, J, M);
d229 4
a232 4
            put_Plot (Avg (Sizes.PLS)(R)(J));               -- 3
            put_Plot (Avg (Sizes.DDS)(R)(J));               -- 4
            put_Plot (Avg (Sizes.DSS)(R)(J));               -- 5
            put_Plot (Avg (Sizes.DXS)(R)(J));               -- 6
d234 4
a237 4
            put_Plot (Avg (Sizes.PLS)(R)(J)/T);             -- 8
            put_Plot (Avg (Sizes.DDS)(R)(J)/T);             -- 9
            put_Plot (Avg (Sizes.DSS)(R)(J)/T);             -- 10
            put_Plot (Avg (Sizes.DXS)(R)(J)/T);             -- 11
d243 4
a246 1
   procedure Run (Filename_Root : String) is
d248 13
a260 25
      Open ();

      declare
         S : Stats.Data := Aperiodic_Tasks (K).Get_Stats;
      begin
         --  just the basics, for now
         Put ("Max_Response_Time = ");
         Put (Integer (S.Max_Response_Time));
         New_Line;
         Put ("Total_Response_Time = ");
         Put (Integer (S.Total_Response_Time));
         New_Line;
         Put ("Job_Count = ");
         Put (Integer (S.Job_Count));
         New_Line;
         Put ("Missed_Deadlines = ");
         Put (Integer (S.Max_Missed_Deadlines));
         New_Line;
      end;
   end loop;
       Close;
   begin end Run;


   end Put;
@
