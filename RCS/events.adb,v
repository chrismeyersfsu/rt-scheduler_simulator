head	1.4;
access;
symbols;
locks; strict;
comment	@-- @;


1.4
date	2008.11.23.01.54.28;	author baker;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.20.18.49.43;	author baker;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.19.12.04.57;	author baker;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.16.13.36.54;	author baker;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@--  $Id$

with Error_Log; use Error_Log;
package body Events is

   function Name (E : Object) return String is
   begin
      return "@@" & Time'Image (E.Event_Time);
   end Name;

   function ">" (L, R : Class_Ref) return Boolean is
   begin
      if L.Event_Time > R.Event_Time then
         return True;
      elsif L.Event_Time < R.Event_Time then
         return False;
      else
         return L.Ordinal > R.Ordinal;
      end if;
   end ">";

   procedure Clear_Queue (Q : in out Queues.Object) is
      E : Events.Class_Ref;
   begin
      while not Q.Is_Empty loop
         E := Q.Front_Of;
         E.Enqueued := False;
         pragma Debug (Trace (3, Name (E.all) & " reset"));
         Q.Pop;
      end loop;
   end Clear_Queue;

end Events;
@


1.3
log
@*** empty log message ***
@
text
@d1 3
d22 11
@


1.2
log
@*** empty log message ***
@
text
@d5 1
a5 1
      return "event at time" & Time'Image (E.Event_Time);
d10 7
a16 1
      return L.Event_Time > R.Event_Time;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   function Event_Image (E : Object) return String is
d6 1
a6 1
   end Event_Image;
d8 1
a8 1
   procedure Event_Handler (E : in out Object) is
d10 2
a11 2
      raise Program_Error;
   end Event_Handler;
@
