head	1.4;
access;
symbols;
locks; strict;
comment	@-- @;


1.4
date	2008.11.23.01.54.28;	author baker;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.20.22.18.50;	author baker;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.20.18.49.43;	author baker;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.19.12.04.57;	author baker;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@--  $Id: replenishments.ads,v 1.3 2008/11/20 22:18:50 baker Exp baker $

with Virtual_Times; use Virtual_Times;
with Generic_Queues;
package Replenishments is

   type R_Info is record
      R_Time : Time;
      R_Amount : Time;
   end record;

   function ">" (Left, Right: R_Info) return Boolean;

   package Queues is new Generic_Queues (R_Info);

   --  Merge_R_Queue coalesces all the replenishments
   --  in Q that have time <= Now, and sets their
   --  replenishment times to Now.

   procedure Merge_R_Queue
      (Q : in out Queues.Object;
       Now : in Time);

   --  Check_R_Sum verifies that the sum of the R_Amounts in Q is
   --  equal to the original Budget.  This is a useful assertion
   --  for catching errors in the replenishment logic.

   procedure Check_R_Sum
      (Q : in out Queues.Object;
       Budget : in Time;
       Msg: String);

   --  Show_R_Queue prints to the log file a list of the elements
   --  of Q.  This can be useful for debugging.

   procedure Show_R_Queue
      (Q : in Queues.Object);

end Replenishments;
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: replenishments.ads,v 1.2 2008/11/20 18:49:43 baker Exp baker $
d16 12
d33 3
d37 1
a37 3
      (Q : in Queues.Object;
       Msg: String;
       Threshold : Integer);
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id$
d16 10
@


1.1
log
@Initial revision
@
text
@d1 2
d6 1
d11 1
d13 1
d15 1
@
