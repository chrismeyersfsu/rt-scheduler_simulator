head	1.6;
access;
symbols;
locks
	baker:1.6; strict;
comment	@-- @;


1.6
date	2008.11.24.02.05.39;	author baker;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.23.01.54.28;	author baker;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.21.23.10.36;	author baker;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.20.22.18.50;	author baker;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.20.18.49.43;	author baker;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.19.12.04.57;	author baker;	state Exp;
branches;
next	;


desc
@@


1.6
log
@*** empty log message ***
@
text
@---  $Id: threads-sched_dss.adb,v 1.5 2008/11/23 01:54:28 baker Exp baker $

--  deadline sporadic scheduler

--  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

--  This version needs more work.  (1) ????  It is currently
--  missing the call(s) to Replenishments.Merge_R_Queue
--  (P.R_Queue, Now); that are needed to coalesce chunks.  (2)
--  ????  The response times on test_four are below M/M/1, which
--  indicates a problem.  Consistency checks for total consumed
--  time seem to validate the simulation, and the tests with
--  background and polling look reasonable, so the problem is
--  probably an overly aggressive DSS implementation, that is
--  giving the server more than its share of time. I'd like a way
--  to check at run-time that a server is not consuming more time
--  than its budget, on the average.  This can be checked roughly
--  by keeping a running average of time used by each task, and
--  comparing it against the utilization returned by the workload
--  model. Exactly how to do this needs more thought.

--  /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

--  ----------
--  Overview
--  ----------

--  The policy is implemented by call-backs that correspond
--  to events that control server priority changes.
--  For each such event there is a scheduler call-back to this policy.

--  In the comments,  Ds = server deadline.
--  In the code, Ds = -P.T.Priority;

--  In the code, server_period = P.T.Policy_Data.Budget_Interval
--  In the code, server_budget = P.T.Policy_Data.Budge

--  In the DSS paper, this is Tz + server_period, wheren
--  Tz = time at which the current server priority became active.
--  Here, everything is in terms of Ds.


--  -----------
--  Initially
--  ------------

--  Ds = Time'last (corresponds to "undefined" in the paper)
--  This is implemented in procedure Bind.

--  -----------------------
--  Server replenishments
--  -----------------------

--  If the server is ready (has work to do)
--  and Ds = Time'Last, then

--  Ds = current_time + server_period

--  This implemented by Replenishment_Events.Handler().

--  -------------------------------------
--  Arrival of an aperiodic job request
--  -------------------------------------

--  If the server has non-empty budget
--  and Tz is not defined (Ds = Time'Last), then do the same as above.

--  This will be detected by the task's arrival event handler, which
--  will eventually call Unsuspend().

--  ---------------------------------
--  Choice of a new task to execute
--  ---------------------------------

--  Let Dc = the deadline of the new task

--  (1) if Tz is undefined

--  If Dc <= current_time + server_period
--  (Ds = Time'Last)
--  Tz = current_time
--  Ds = current time + server_period

--  (2) if Tz is defined

--  If Dc > current_time + server_period
--  Tz = undefined (Time'Last)
--  Ds = Time'Last

--  If Dc <= current_time + server_period
--  and Ds <= Dc,
--  Ds = Dc - server_period

--  This is implemented by New_Current_Thread().

--  ------------------------------
--  Server priority "activation"
--  ------------------------------

--  Actually, any time the server priority is inactive,
--  or the instant where the server priority becomes active.

--  Coalesce all the available chunks into a single chunk
--  with replenishment time equal to the current time.

--  These events are not easy to detect, since the
--  server priority varies.  Since this is only an
--  optimization to reduce fragmentation, we have some
--  flexibility about when we do it, but
--  the results will differ in replenishment time,
--  which might affect serer performance.

--  This is implemented by New_Current_Thread().

--  ---------------------------------------------
--  Server starts to execute a new budget chunk
--  ---------------------------------------------

--  Tz = chunk replenishment time
--  Ds = chunk.replenishment_time + server_period

--  This is implemented in Budget_Exhaustion_Events.Handler().

--  ---------------------------------
--  Server completes a budget chunk
--  ---------------------------------

--  (1) The amount of time consumed by the server is split off
--  and scheduled for replenishment at the current deadline of
--  the server

--  (2) If there is another chunk, the server executes using that

--  (3) If there are no more chunks, the server becomes inactive

--  This is implemented in Budget_Exhaustion_Events.Handler().

--  -------------------------------------------------
--  Server suspends itself (for an empty job queue)
--  -------------------------------------------------

--  Do the same as (1) above, except that we can't assume the chunk
--  has been exhausted.

--  This is implemented in Suspend().

--  --------------------------------
--  The entire system becomes idle
--  --------------------------------

--  This event is not important for the DSS algorithm, but
--  notification of this event may be needed for some other server
--  algorithms, to merge all server replenishments and set
--  the replenishment amount to full budget.

--  To catch this event, one can use the New_Current_Thread call-out,
--  and check for Current_Thread = Idle_Thread.

with Replenishments; use Replenishments;
with Simulator;
with Error_Log; use Error_Log;
with Ada.Text_IO; use Ada.Text_IO;
package body Threads.Sched_DSS is

   type Policy_Ref is access all Object;

   --  Debugging Support

   procedure Trace_R_Queue
     (Threshold : Integer;
      P : Policy_Ref;
      Msg : String) is
   begin
      if Debug_Level >= Threshold then
         Put (Log, Name (P.T.all));
         Put (Log, Msg);
         Put (Log, " with R_Queue = ");
         Show_R_Queue (P.R_Queue);
         New_Line (Log);
      end if;
   end Trace_R_Queue;

   procedure Trace
     (Threshold : Integer;
      P : Policy_Ref;
      Msg : String) is
   begin
      if Debug_Level >= Threshold then
         Put (Log, Name (P.T.all));
         Put (Log, Msg);
         New_Line (Log);
      end if;
   end Trace;

   procedure Trace_Time
     (Threshold : Integer;
      P : Policy_Ref;
      Msg : String;
      T : Time) is
   begin
      if Debug_Level >= Threshold then
         Put (Log, Name (P.T.all));
         Put (Log, Msg);
         Put (Log, " at");
         Put (Log, Time'Image (T));
         New_Line (Log);
      end if;
   end Trace_Time;

   procedure Trace_Priority
     (Threshold : Integer;
      P : Policy_Ref;
      Msg : String) is
   begin
      if Debug_Level >= Threshold then
         Put (Log, Name (P.T.all));
         Put (Log, "priority ->");
         Put (Log, Time'Image (P.T.Priority));
         Put (Log, " in ");
         Put (Log, Msg);
         New_Line (Log);
      end if;
   end Trace_Priority;

   procedure Check_Usage
     (Threshold : Integer;
      Used : Time;
      P : Policy_Ref;
      R : R_Info) is
   begin
      if Debug_Level >= Threshold and then
        Used > R.R_Amount - P.Usage then
         Put_Line (Log, "* used time > budget: used =" & Time'Image (Used)
                & " R.R_Amount =" & Time'Image (R.R_Amount)
                & " P.Usage" & Time'Image (P.Usage)
                & " P.Last_Update_Time" & Time'Image (P.Last_Usage_Update_Time));
         pragma Assert (False);
      end if;
   end Check_Usage;

   ----------------------------
   --  Replenishment_Events  --
   ----------------------------

   package body Replenishment_Events is

      procedure Handler (E : in out Object) is
         --  Cast type of policy
         --  to the specific type for this policy.
         P : constant Policy_Ref := Policy_Ref (E.T.Policy);
         Now : constant Time := Simulator.Current_Time;
      begin
         pragma Debug (Trace (3, P, "replenishment handler (dss)"));
         pragma Assert (P.R_Queue.Front_Of.R_Time = Now);
         --  Update the thread's priority (deadline) and
         --  let it contend for the processor.
         P.T.Priority := Now + P.Parms.Budget_Interval;
         pragma Debug (Trace_Priority (5, P, "replenishment handler"));
         Policy_Unsuspend (E.T);
         Schedule;
      end Handler;

      function Name (E : Object) return String is
      begin
         return Name (E.T.all) & "replenishment " & Events.Object (E).Name;
      end Name;

   end Replenishment_Events;

   --------------------
   --  Update_Usage  --
   --------------------

   --  Called for both budget exhaustion (from timer)
   --  and for self-suspension, to check for and handle
   --  budget exhaustion.  It also updates the current
   --  budget usage.

   --  So, it may be executed twice in succession, first from the
   --  Budget_Exhaustion event handler, and then again from the
   --  Stop event handler as a consequence of policy-suspension
   --  causing the scheduler to stop the thread.  The second call
   --  should fall through without any action.

   procedure Update_Usage (P : Policy_Ref;
                           Msg : String) is
      Used : Time;
      Now : constant Time := Simulator.Current_Time;
      R, R2 : R_Info;
   begin

      if P.Exhaustion.Enqueued then
         Simulator.Cancel_Event (P.Exhaustion);
         pragma Debug (Trace (5, P, "cancelled exhaustion"));
      end if;

      R := P.R_Queue.Front_Of;
      Used := Now - P.Last_Usage_Update_Time;
      pragma Debug (Check_Usage (3, Used, P, R));
      if Used = 0 then
         pragma Debug (Trace (2, P, "skipping second call to Update_Usage"));
         null;
      else
         --  cancel budget timeout, if one is pending.

         P.Usage := P.Usage + Used;
         P.Last_Usage_Update_Time := Now;
         pragma Debug (Trace_R_Queue (7, P, "last_usage_update_time (1)"));

         --  If thread is suspended, split off the used part of budget.
         if P.T.Is_Suspended then
            pragma Debug (Trace (5, P, "is suspended"));
            P.R_Queue.Pop;
            R2.R_Amount := P.Usage;
            R2.R_Time := P.T.Priority;
            P.R_Queue.Add (R2);
            R.R_Amount := R.R_Amount - P.Usage;
            P.Usage := 0;
            pragma Assert (R.R_Amount >= 0);
            if R.R_Amount = 0 then
               R := P.R_Queue.Front_Of;
               --  Update thread deadline to match new chunk.
               --  Since this can only be later, it cannot alter
               --  a decision to preempt this thread.
               P.T.Priority := R.R_Time + P.Parms.Budget_Interval;
               pragma Debug (Trace (7, P, "starting new budget chunk"));
               pragma Debug (Trace_Priority (5, P, Msg));
            else
               P.R_Queue.Add (R);
            end if;
         elsif P.Usage = R.R_Amount then
            --  update replenishment time of consumed chunk
            P.R_Queue.Pop;
            P.Usage := 0;
            R.R_Time := P.T.Priority;
            P.R_Queue.Add (R);
            R := P.R_Queue.Front_Of;
         else
            pragma Debug (Trace_R_Queue (7, P, "usage < amount?" &
                    " P.Usage =" & Time'Image (P.Usage) &
                    " R.R_Amount =" & Time'Image (R.R_Amount)));
            null;
         end if;

         -- R holds the earliest chunk in P.R_Queue

         pragma Assert (R.R_Amount > 0);

         if R.R_Time > Now and then
            not P.T.Is_Policy_Suspended then
            --  Suspend the server until the replenishment.
            Policy_Suspend (P.T);
            --  Schedule a replenishment event.
            P.Replenishment.Event_Time := R.R_Time;
            Simulator.Schedule_Event (P.Replenishment);
            pragma Debug (Trace_Time (5, P, "next replenishment due", R.R_Time));
         else
            pragma Debug (Trace (5, P, "not policy suspended"));
            null;
         end if;
      end if;

      pragma Debug (Check_R_Sum
                    (P.R_Queue, P.Parms.Budget, Msg));
      pragma Debug (Trace_R_Queue (6, P, "leaving update_usage"));

   end Update_Usage;

   --------------------------------
   --  Budget_Exhaustion_Events  --
   --------------------------------

   package body Budget_Exhaustion_Events is

      procedure Handler (E : in out Object) is
         P : constant Policy_Ref := Policy_Ref (E.T.Policy);
      begin
         pragma Debug (Trace (3, P, "chunk exhaustion handler (dss)"));
         --  Update budget usage, and replenishment info.
         Update_Usage (P, "Budget_Exhaustion");
         if P.T.Is_Policy_Suspended then
            Schedule;
         else
            --  Set up exhaustion event for the new chunk
            P.Exhaustion.Event_Time := Simulator.Current_Time
              + P.R_Queue.Front_Of.R_Amount;
            Simulator.Schedule_Event (P.Exhaustion);
            pragma Debug (Trace_Time (5, P, "chunk will exhaust", P.Exhaustion.Event_Time));
         end if;
      end Handler;

      function Name (E : Object) return String is
      begin
         return Name (E.T.all)
           & "budget_exhaustion " & Events.Object (E).Name;
      end Name;

   end Budget_Exhaustion_Events;

   ----------
   --  Go  --
   ----------

   --  This is called whenever Current_Thread is set to a new
   --  value, for the new thread.  It indicates that the
   --  thread has just started or resumed executing, after
   --  a suspension or preemption.

   procedure Go
     (P : in out Object) is
      Now : constant Time := Simulator.Current_Time;
   begin
      pragma Debug (Trace (9, P'Unchecked_Access, "go handler (dss)"));

      --  Schedule a timer for when the current replenishment
      --  chunk will run out, assuming the thread runs that long.

      P.Exhaustion.Event_Time := Now + (P.R_Queue.Front_Of.R_Amount - P.Usage);
      Simulator.Schedule_Event (P.Exhaustion);
      pragma Debug (Trace_Time (5, P'Unchecked_Access, "chunk will exhaust (Go)", P.Exhaustion.Event_Time));

      P.Last_Usage_Update_Time := Now;
      pragma Debug (Trace_R_Queue (7, P'Unchecked_Access, "last_usage_update_time (2)"));

   end Go;

   ------------
   --  Stop  --
   ------------

   --  This is called whenever Current_Thread is set to a new
   --  value, for the old current thread.  It indicates that the
   --  thread has been self-suspended, preempted, or
   --  policy-suspended.

   procedure Stop
     (P : in out Object) is
   begin
      pragma Debug (Trace (9, P'Unchecked_Access, "stop handler (dss)"));

      --  Cancel budget timeout, Update budget usage, and schedule
      --  replenishments, if necessary.

      Update_Usage (P'Unchecked_Access, "Stop");

   end Stop;

   ------------------
   --  Bind_Parms  --
   ------------------

   procedure Bind_Parms
     (P : in out Object;
      Parms : Aperiodic_Server_Parameters.Parameters) is
   begin
      P.Parms := Parms;
   end Bind_Parms;

   ------------
   --  Init  --
   ------------

   procedure Init
     (P : in out Object) is
   begin
      P.T.Priority :=  Time'Last;
      P.Replenishment.T := P.T;
      P.Exhaustion.T := P.T;
      P.R_Queue.Clear;
      --  set up first replenishment
      P.R_Queue.Add ((R_Time => 0,
                      R_Amount => P.Parms.Budget));
      P.T.Is_In_Ready_Queue := False;
      P.T.Is_Policy_Suspended := False;
      P.Usage := 0;
      P.Last_Usage_Update_Time := Time'Last;
      -- to catch failure to set real value before use
   end Init;

   -------------------------
   --  New_Current_Thread --
   -------------------------

   --  This is called for *ALL* threads :-( whenever the value of
   --  Current_Thread has changed.

   procedure New_Current_Thread
     (P : in out Object) is
      DC : Time;
      DS : Time := P.T.Priority;
      TD : constant Time :=
        Simulator.Current_Time + P.Parms.Budget_Interval;
   begin
      if Current /= null then
         DC := Current.Priority;
      else
         DC := Time'Last;
      end if;
      if DC > TD then
         DS := Time'Last; -- "undefined"
      elsif DS <= DC then
         DS := Time'Min (DC, TD);
      end if;
      P.T.Priority := DS;
      pragma Debug (Trace_Priority (5, P'Unchecked_Access, "new_current_thread"));
   end New_Current_Thread;

   -----------------
   --  Unsuspend  --
   -----------------

   --  This is called whenever a thread that earlier suspended
   --  itself wakes up. For a server, this means a job has arrived
   --  for a server previously had no jobs in its queue.

   procedure Unsuspend (P : in out Object) is
   begin

      if P.T.Priority = Time'Last then
         P.T.Priority := Simulator.Current_Time + P.Parms.Budget_Interval;
         pragma Debug (Trace_Priority (5, P'Unchecked_Access, "unsuspend"));
      end if;

   end Unsuspend;

   ---------------
   --  Suspend  --
   ---------------

   --  This is called whenever a thread has suspended itself.  For
   --  a server, this means the server has no jobs in its queue.

   procedure Suspend (P : in out Object) is
   begin
      null;
   end Suspend;

end Threads.Sched_DSS;
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a1 1
---  $Id: threads-sched_dss.adb,v 1.4 2008/11/21 23:10:36 baker Exp baker $
d5 1
a5 5
--  ??? With all these events, and duplicate data between the task
--  and thread views, this "object oriented" version of the
--  program has become a lot more complicated (and likely to run
--  slower) than the old monolithic model with global visibility
--  of all information. :-{
d7 16
d231 1
a231 1
      if Debug_Level > Threshold and then
@


1.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: threads-sched_dss.adb,v 1.3 2008/11/20 22:18:50 baker Exp baker $
d57 1
a57 1
--  will eventuall call Unsuspend().
d89 1
a89 1
--   or the instant where the server priority becomes active.
d94 7
d113 1
a113 1
--  Server completes a budgdt chunk
d155 74
d241 7
a247 2
         pragma Assert (not P.R_Queue.Is_Empty);
         Policy_Unsuspend (E.T, Now + P.Parms.Budget_Interval);
d258 99
a363 1
         Now : constant Time := Simulator.Current_Time;
a364 1
         R : R_Info;
d366 4
a369 24
         pragma Assert (not P.R_Queue.Is_Empty);
         R := P.R_Queue.Front_Of;
         P.R_Queue.Pop;
         R.R_Time := E.T.Priority;
         --  Set replenishment time to current deadline.
         --  The amount should be unchanged.
         --  Put the replenishment back in queue, in new position.
         P.R_Queue.Add (R);
         pragma Debug (Check_R_Sum
                       (P.R_Queue, P.Parms.Budget,"Exhaustion"));
         --  Fetch the earliest replenishment chunk
         R := P.R_Queue.Front_Of;
         --  Only schedule a replenishment event if we need to.
         if R.R_time > Now then
            --  We need to set a timer for the replenishment.
            P.Replenishment.Event_Time := R.R_Time;
            Simulator.Schedule_Event (P.Replenishment);
            pragma Debug (Debug (5, Name (P.T.all) &
                                   "next replenishment due at" &
                                   Time'Image (R.R_Time)));
            --  Suspend this thread until the replenishment arrives.

            Policy_Suspend (P.T);
            --  Call the scheduler to choose another thread.
d372 5
a376 8
            --  We can continue, using the next relenishment chunk.
            pragma Debug
              (Debug (7, Name (P.T.all)
                        & "starting new replenishment chunk"));
            --  Start using the new chunk (**)
            --  The priority is the chunk arrival time
            --  plus the server "period"
            P.T.Priority := R.R_Time + P.Parms.Budget_Interval;
d382 2
a383 1
         return Name (E.T.all) & "budget_exhaustion " & Events.Object (E).Name;
d399 1
d401 1
a401 2
      pragma Debug (Check_R_Sum (P.R_Queue, P.Parms.Budget, "Go"));
      pragma Assert (not P.R_Queue.Is_Empty);
d406 1
a406 2
      P.Exhaustion.Event_Time :=
        Simulator.Current_Time + P.R_Queue.Front_Of.R_Amount;
d408 5
d421 2
a422 1
   --  thread has been suspended or preempted.
d427 4
d432 1
a432 1
      --  Cancel budget timeout, if one is pending.
a433 3
      if P.Exhaustion.Enqueued then
         Simulator.Cancel_Event (P.Exhaustion);
      end if;
d462 4
d476 1
a476 1
     (P : Object) is
d493 1
d500 3
a502 2
   --  This is called whenever a thread has suspended itself.  For
   --  a server, this means the server has no jobs in its queue.
d504 1
a504 1
   procedure Unsuspend (P : Object) is
d506 1
d509 1
d511 1
d518 2
a519 3
   --  This is called whenever a thread that earlier suspended
   --  itself wakes up. For a server, this means a job has arrived
   --  for a server previously had no jobs in its queue.
a521 2
      Now : constant Time := Simulator.Current_Time;
      R, R2 : R_Info;
d523 1
a523 31
      pragma Assert (not P.R_Queue.Is_Empty);
      R := P.R_Queue.Front_Of;
      P.R_Queue.Pop;
      R2.R_Amount := Simulator.Current_Time - Last_Dispatching_Time;
      --  ??? or, should we rely on task's own view of when it started,
      --  by using P.T.Last_Start_Time insteasd of Scheduler.Last_Dispatch_Time?
      R2.R_Time := P.T.Priority;  -- = deadline
      P.R_Queue.Add (R2);
      R.R_Amount := R.R_Amount - R2.R_Amount;
      --  R.R_Time is unchanged
      pragma Assert (R.R_Amount >= 0);
      if R.R_Amount > 0 then
         P.R_Queue.Add (R);
      end if;
      pragma Debug (Check_R_Sum (P.R_Queue, P.Parms.Budget, "Suspend"));
      R := P.R_Queue.Front_of;
      if R.R_time > Now then
         P.Replenishment.Event_Time := R.R_Time;
         Simulator.Schedule_Event (P.Replenishment);
         pragma Debug (Debug (5, Name (P.T.all) &
                                "next replenishment due at" &
                                Time'Image (R.R_Time)));
         Policy_Suspend (P.T);
         Schedule;
      else
         pragma Debug
           (Debug (7, Name (P.T.all)
                     & "starting new replenishment chunk"));
         --  start using new chunk (**)
         P.T.Priority := R.R_Time + P.Parms.Budget_Interval;
      end if;
a525 17
   ---------------
   --  New_Job  --
   ---------------

   --  This is called when a server starts working on a new job
   --  from its queue.  We don't need this for most (all?)
   --  aperiodic server policies, but we may need this to provide
   --  the deadline for periodic tasks that are scheduled
   --  according to individual job deadlines.

   procedure New_Job
     (P : in out Object;
      J : in Jobs.Job) is
   begin
      P.Current_Job := J;
   end New_Job;

@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: threads-sched_dss.adb,v 1.2 2008/11/20 18:49:43 baker Exp baker $
d348 1
a348 1
      R1, R2 : R_Info;
d351 1
a351 1
      R1 := P.R_Queue.Front_Of;
d358 5
a362 8
      R1.R_Amount := R1.R_Amount - R2.R_Amount;
      --  R1.R_Time is unchanged
      Put (Log, Time'Image (R1.R_Amount));
      Put (Log, Time'Image (R2.R_Amount));
      New_Line (Log);
      pragma Assert (R1.R_Amount >= 0);
      if R1.R_Amount > 0 then
         P.R_Queue.Add (R1);
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: threads-sched_dss.adb,v 1.1 2008/11/19 12:04:57 baker Exp baker $
d9 130
a138 1
--  of all information.
a147 36
   --------------------------------------
   --  Assertion Checking & Debugging  --
   --------------------------------------

   procedure Check_R_Queue (P : in out Object; Msg: String) is
      Total : Time := 0;
      procedure Check_One (R : R_Info) is
      begin
         Total := Total + R.R_Amount;
      end Check_One;
      procedure Check_All is new
        Replenishments.Queues.For_All (Check_One);
   begin
      Check_All (P.R_Queue);
      pragma Assert (Total = P.Parms.Budget, Msg);
   end Check_R_Queue;

   procedure Show_R_Queue (P : in out Object;
                           Msg: String;
                           Threshold : Integer) is
      Total : Time := 0;
      procedure Show_One (R : R_Info) is
      begin
         Put (Log, '[' & Time'Image (R.R_Time)
                &  Time'Image (R.R_Amount) & ']');
      end Show_One;
      procedure Show_All is new
        Replenishments.Queues.For_All (Show_One);
   begin
      if Debug_Level > Threshold then
         Put (Log, ' ');
         Show_All (P.R_Queue);
         New_Line (Log);
      end if;
   end Show_R_Queue;

d172 3
a174 28
   procedure Check_Budget (T : Thread_Ref) is
      Now : constant Time := Simulator.Current_Time;
      P : constant Policy_Ref := Policy_Ref (T.Policy);
      R : R_Info;
   begin
      pragma Assert (not P.R_Queue.Is_Empty);
      R := P.R_Queue.Front_of;
      if R.R_time > Now then
         P.Replenishment.Event_Time := R.R_Time;
         Put_Line (Log, "--8--");
         Simulator.Schedule_Event (P.Replenishment);
         if Debug_Level > 5 then
            Put_Line (Log, Name (T.all) &
                        "no available replenishment chunks at"
                     & Time'Image (Now));
            Simulator.Show_Event_Queue (Log);
         end if;
         Policy_Suspend (T);
         Schedule;
      else
         pragma Debug (Show_R_Queue (P.all, "budget exhaustion", 7));
         pragma Debug
           (Debug (7, Name (T.all) & "starting new replenishment chunk at"
                     & Time'Image (Now)));
         --  start using new chunk (**)
         T.Priority := R.R_Time + P.Parms.Budget_Interval;
      end if;
   end Check_Budget;
d179 1
a182 1
         pragma Debug (Show_R_Queue (P.all, "budget exhaustion", 7));
d186 32
a217 5
         R.R_Time := E.T.Priority; --  = deadline
         --  R_Amount should be unchanged
         P.R_Queue.Add (R);  -- add replenishment to queue
         pragma Debug (Check_R_Queue (P.all, "Exhaustion"));
         Check_Budget (E.T);
d231 5
d239 1
a239 4
      --  Compute the amount of time left until the current
      --  replenishment chunk will run out, assuming the thread
      --  runs that long.
      Check_R_Queue (P, "Go");
d241 4
a246 2
      --  Set budget timeout
      Put_Line (Log, "--4--");
d254 4
d261 3
a263 4
      --  Cancel budget timeout
      --  ??? If there is no event to cancel, no damage should be done,
      --  but it would be cleaner to avoid this call in that case.
      Put_Line (Log, "--3--");
d269 3
a271 18
   --  This is implemented by call-backs that correspond
   --  to events that control server priority changes.
   --  For each such event there is a scheduler call-back to this policy.

   --  In the comments,  Ds = server deadline.
   --  In the code, Ds = -P.T.Priority;

   --  In the code, server_period = P.T.Policy_Data.Budget_Interval
   --  In the code, server_budget = P.T.Policy_Data.Budge

   --  In the DSS paper, this is Tz + server_period, wheren
   --  Tz = time at which the current server priority became active.
   --  Here, everything is in terms of Ds.

   --  Initially
   --------------

   --  Ds = Time'last (corresponds to "undefined" in the paper)
d280 4
d297 3
a299 36
   --  When server gets a replenishment
   ------------------------------------

   --  If the server is ready (has work to do)
   --  and Ds = Time'Last, then
   --  Ds = current_time + server_period

   --  See Replenishment_Events.Handler, above.

   --  When an aperiodic job request arrives
   -----------------------------------------

   --  If the server has non-empty budget
   --  and Tz is not defined (Ds = Time'Last), then do the same as above.

   --  This will be detected by the task's arrival event handler,
   --  which will eventuall call Unsuspend

   procedure Unsuspend (P : Object) is
   begin
      if P.T.Priority = Time'Last then
         P.T.Priority := Simulator.Current_Time + P.Parms.Budget_Interval;
      end if;
   end Unsuspend;

   --  When a new task is chosen to execute
   ----------------------------------------

   --  Let Dc = the deadline of the new task

   --  (1) if Tz is undefined

   --  If Dc <= current_time + server_period
   --  (Ds = Time'Last)
   --  Tz = current_time
   --  Ds = current time + server_period
d301 2
a302 9
   --  (2) if Tz is defined

   --  If Dc > current_time + server_period
   --  Tz = undefined (Time'Last)
   --  Ds = Time'Last

   --  If Dc <= current_time + server_period
   --  and Ds <= Dc,
   --  Ds = Dc - server_period
d324 3
a326 3
   --  (*) Any time the server priority is inactive,
   --  or the instant where the server priority becomes active.
   ------------------------------------------------------------
d328 2
a329 2
   --  Coalesce all the available chunks into a single chunk
   --  with replenishment time equal to the current time.
d331 6
a336 22
   --  ....how to implement this?

   --  When the server starts to execute a new chunk
   -------------------------------------------------

   --  Tz = chunk replenishment time
   --  Ds = chunk.replenishment_time + server_period

   --  (**) This is implemented in Budget_out, below.

   --  When the server completes a chunk
   -------------------------------------

   --  (1) the amount of time consumed by the server is split off
   --  and scheduled for replenishment at the current deadline of
   --  the server

   --  (2) if there is another chunk, the server executes using that

   --  (3) if there are no more chunks, the server becomes inactive

   --  See Budget_Exhaustion_Events.Handler, above.
d338 7
a344 5
   --  When the server suspends itself (for an empty queue)
   --------------------------------------------------------

   --  Do the same as (1) above,
   --  except that we can't assume the chunk has been exhausted.
d347 1
a349 3
      --  pragma Assert (P.T = Current);
      --  suspension could be delayed, due to reordering of
      --  concurrent completion, budget exhaustion, preemption, etc.
d360 3
d367 17
a383 2
      pragma Debug (Check_R_Queue (P, "Suspend"));
      Check_Budget (P.T);
d386 9
a394 6
   --  Starting a new job
   ----------------------

   --  We may need this to provide the deadline, for policies
   --  that use individual job deadlines.
   --  It is not used for DSS.
a402 15
   --  When the entire system becomes idle
   ---------------------------------------

   --  This, too,  is not part of the DSS algorithm, but
   --  notification of this event may be needed for some other server
   --  algorithms, to merge all server replenishments, and set
   --  replenishment amount to full budget.

   --  We don't use this event in the case of the DSS,
   --  because we already seem to be covering this case by rule
   --  (*) above.

   --  To catch this event, one can use the New_Current_Threadk call-out,
   --  and check for Current_Thread = Idle_Thread

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
--  $Id$
a10 1
with Aperiodic_Server_Parameters; use Aperiodic_Server_Parameters;
d13 2
d17 1
a17 7
   package Replenishment_Events is
      type Object is new Events.Object with record
         T : Thread_Ref;
      end record;
      procedure Handler (E : in out Object);
      function Name (E : Object) return String;
   end Replenishment_Events;
d19 35
a53 7
   package Budget_Exhaustion_Events is
      type Object is new Events.Object with record
         T : Thread_Ref;
      end record;
      procedure Handler (E : in out Object);
      function Name (E : Object) return String;
   end Budget_Exhaustion_Events;
d55 3
a57 7
   type Policy_Data is new Threads.Scheduling_Policies_Data.Object with record
      R_Queue : Replenishments.Queues.Object;
      Replenishment : aliased Replenishment_Events.Object;
      Exhaustion: aliased Budget_Exhaustion_Events.Object;
      Current_Job : Jobs.Object;
   end record;
   type Policy_Data_Ref is access all Policy_Data;
d60 1
d62 4
a65 5
         T : Thread_Ref := E.T;
         --  Cast types of policy data and parameters from
         --  class to the specific types for this policy.
         D : Policy_Data_Ref := Policy_Data_Ref (T.Policy_Data);
         PR : Parms_Ref := Parms_Ref (T.Parms);
d67 3
a69 4
         pragma Assert (not D.R_Queue.Is_Empty);
         if not T.Is_Suspended and then T.Priority = Time'Last then
            T.Priority := Simulator.Current_Time + PR.Budget_Interval;
         end if;
d71 1
a72 1
         T : Thread_Ref := E.T;
d74 1
a74 1
         return T.Name & " replenishment " & Events.Object (E).Name;
d76 1
d79 3
a81 4
   procedure Check_Budget (T : Thread_Ref;
                           D : Policy_Data_Ref;
                           PR : Parms_Ref) is
      Now : Time := Simulator.Current_Time;
d84 2
a85 2
      pragma Assert (not D.R_Queue.Is_Empty);
      R := D.R_Queue.Front_of;
d87 11
a97 3
         T.Priority := Time'Last;
         D.Replenishment.Event_Time := R.R_Time;
         Simulator.Schedule_Event (D.Replenishment);
d99 4
d104 1
a104 1
         T.Priority := R.R_Time + PR.Budget_Interval;
d109 1
d111 1
a111 3
         T : Thread_Ref := E.T;
         PR : Parms_Ref := Parms_Ref (T.Parms);
         D : Policy_Data_Ref := Policy_Data_Ref (T.Policy_Data);
d114 5
a118 4
         pragma Assert (not D.R_Queue.Is_Empty);
         R := D.R_Queue.Front_Of;
         D.R_Queue.Pop;
         R.R_Time := T.Priority; --  = deadline
d120 3
a122 2
         D.R_Queue.Add (R);  -- add replenishment to queue
         Check_Budget (T, D, PR);
d124 1
a125 1
         T : Thread_Ref := E.T;
d127 1
a127 1
         return T.Name & " budget exhaustion " & Events.Object (E).Name;
d129 1
d137 1
a137 3
     (P : Object;
      T : Thread_Ref) is
      D : Policy_Data_Ref := Policy_Data_Ref (T.Policy_Data);
d142 4
a145 2
      D.Replenishment.Event_Time :=
        Simulator.Current_Time + D.R_Queue.Front_Of.R_Amount;
d147 2
a148 1
      Simulator.Schedule_Event (D.Replenishment);
d156 1
a156 3
     (P : Object;
      T : Thread_Ref) is
      D : Policy_Data_Ref := Policy_Data_Ref (T.Policy_Data);
d161 4
a164 1
      Simulator.Cancel_Event (D.Exhaustion);
d172 1
a172 1
   --  In the code, Ds = -T.Priority;
d174 2
a175 2
   --  In the code, server_period = T.Policy_Data.Budget_Interval
   --  In the code, server_budget = T.Policy_Data.Budge
d186 14
a199 14
   procedure Init (P : in out Object;
                   T : Thread_Ref) is
      D : Policy_Data_Ref;
      PR : Parms_Ref := Parms_Ref (T.Parms);
   begin
      if T.Policy /= null then
         pragma Assert (T.Policy = P'Unchecked_Access);
         null;
      else
         T.Policy := P'Unchecked_Access;
         D := new Policy_Data;
         T.Policy_Data := Policy_Data_Class_Ref (D);
      end if;
      T.Priority :=  Time'Last;
d201 3
a203 8
      D.R_Queue.Add (R_Info'
                       (R_Time => 0,
                        R_Amount => PR.Budget));
      T.Is_Suspended := True;
      T.Is_In_Ready_Queue := False;
      D.R_Queue.Clear;
      --  ... mising code here to create a list of all
      --  tasks scheduled by this policy
d224 1
a224 3
   procedure Unsuspend (P : Object;
                        T : Thread_Ref) is
      PR : Parms_Ref := Parms_Ref (T.Parms);
d226 2
a227 2
      if T.Priority = Time'Last then
         T.Priority := Simulator.Current_Time + PR.Budget_Interval;
d254 5
a258 6
     (P : Object;
      Notified_Thread : Thread_Ref) is
      DC : Time := Current.Priority;
      DS : Time := Notified_Thread.Priority;
      PR : Parms_Ref := Parms_Ref (Notified_Thread.Parms);
      TD : Time := Simulator.Current_Time + PR.Budget_Interval;
d260 5
d270 1
a270 1
      Notified_Thread.Priority := DS;
d306 1
a306 1
   --  Do the same as above,
d309 1
a309 2
   procedure Suspend (P : Object;
                      T : Thread_Ref) is
a310 2
      D : Policy_Data_Ref := Policy_Data_Ref (T.Policy_Data);
      PR : Parms_Ref := Parms_Ref (T.Parms);
d312 6
a317 4
      pragma Assert (T = Current);
      pragma Assert (not D.R_Queue.Is_Empty);
      R1 := D.R_Queue.Front_Of;
      D.R_Queue.Pop;
d320 3
a322 3
      --  by using T.Last_Start_Time insteasd of Scheduler.Last_Dispatch_Time?
      R2.R_Time := T.Priority;  -- = deadline
      D.R_Queue.Add (R2);
d327 1
a327 1
         D.R_Queue.Add (R1);
d329 2
a330 1
      Check_Budget (T, D, PR);
d340 3
a342 5
   procedure Change_Job
     (P : Object;
      T : Thread_Ref;
      J : in Jobs.Object) is
      D : Policy_Data_Ref := Policy_Data_Ref (T.Policy_Data);
d344 2
a345 2
      D.Current_Job := J;
   end Change_Job;
@
