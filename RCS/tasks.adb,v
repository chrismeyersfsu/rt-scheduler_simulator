head	1.7;
access;
symbols;
locks; strict;
comment	@-- @;


1.7
date	2008.11.24.02.05.39;	author baker;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.23.21.33.20;	author baker;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.23.01.54.28;	author baker;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.21.23.10.36;	author baker;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.20.22.18.50;	author baker;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.20.18.49.43;	author baker;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.19.12.04.57;	author baker;	state Exp;
branches;
next	;


desc
@@


1.7
log
@*** empty log message ***
@
text
@--  $Id: tasks.adb,v 1.6 2008/11/23 21:33:20 baker Exp baker $

with Simulator;
with Threads;
with Generic_Queues;
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Strings; use Ada.Strings;
with Ada.Strings.Fixed; use Ada.Strings.Fixed;
with Error_Log; use Error_Log;
package body Tasks is

   ----------------
   --  All_Tasks --
   ----------------

   --  A list of all the tasks we have bound.  This is convenient
   --  for (re) initializing all the tasks.
   --  The order is not important.

   function ">" (L, R : Task_Ref) return Boolean is
   begin
      return L.Name > R.Name;
   end ">";
   package Task_Queues is new Generic_Queues (Task_Ref);

   All_Tasks : Task_Queues.Object;

   --  to catch "recursive" event handling
   Handling_Event : Integer := 0;

   procedure Up (Level : Integer; Msg : String) is
   begin
      Trace (11,
             Integer'Image (Handling_Event) &
               "->" & Integer'Image (Level) & ' ' & Msg);
      pragma Assert (Handling_Event < Level);
      Handling_Event := Handling_Event + 1;
   end Up;

   procedure Down is
   begin
      Trace (11, "<-");
      Handling_Event := Handling_Event - 1;
   end Down;

   ------------
   --  Bind  --
   ------------

   procedure Bind
     (T : Task_Ref;
      M : Workload_Models.Class_Ref;
      P : Threads.Policies_Class_Ref;
      Name : String) is
      use Threads;
   begin
      T.Model := M;
      T.Arrival.T := T;
      T.Completion.T := T;
      --  Set the ordinals to force arrivals to be simulated after
      --  completions, but leave some room in between for use by
      --  extensions.
      T.Completion.Ordinal := 0;
      T.Arrival.Ordinal := 2;
      --  We don't need ordinals on the Stop and Go events,
      --  because they are not "real" events.
      --  They are just a convenient way for the thread
      --  scheduler to signal back to the task when it is
      --  to stop and go.
      T.Go.T := T;
      T.Stop.T := T;
      Move (Trim (Name, Right), T.Name,
            Drop => Right, Justify => Left, Pad => ' ');
      if T.Thread = null then
         T.Thread := Threads.New_Thread
           (Go => T.Go'Unchecked_Access,
            Stop => T.Stop'Unchecked_Access,
            Name => T.Name);
      end if;
      Threads.Bind_Policy (T.Thread, P);
      P.Bind_Thread (T.Thread);
      if not T.Is_In_All_Tasks then
         All_Tasks.Add (T);
         T.Is_In_All_Tasks := True;
      end if;
   end Bind;

   -------------------
   --  Reset_Stats  --
   -------------------

   procedure Reset_Stats_Once
     (T : Task_Ref) is
   begin
      T.Stats_Data :=
        (Max_Resp_Time => 0,
         Total_Resp_Time => 0.0,
         Total_Sq_Resp_Time => 0.0,
         Total_Exec_Time => 0,
         Job_Count => 0,
         Missed_Deadlines => 0);
   end Reset_Stats_Once;

   procedure Reset_Queue is
      new Task_Queues.For_All (Reset_Stats_Once);
   procedure Reset_Stats is
   begin
      Reset_Queue (All_Tasks);
   end Reset_Stats;

   ------------
   --  Init  --
   ------------

   procedure Init
     (T : Task_Ref) is
      use Threads;
   begin
      T.Running := False;
      Reset_Stats_Once (T);
      T.Current_Job :=
        (Arrival_Time => 0,
         Execution_Time => 0,
         Absolute_Deadline => 0);
      T.Remaining_Exec_Time := 0;
      T.Total_Exec_Time := 0;
      T.Pending_Jobs.Clear;
      --  We don't need to initialize T.Thread here
      --  since Initialize will call Threads.Initialize,
      --  and that will (re)initialize all threads.
      T.Arrival.Event_Time := T.Model.Start_Time;
      pragma Debug (Trace (3, Name (T.all) &  "scheduling"));
      Simulator.Schedule_Event (T.Arrival);
      pragma Debug (Trace (3, Name (T.all) &  "scheduled"));
   end Init;

   ------------------
   --  Initialize  --
   ------------------

   procedure Initialize_Queue is new Task_Queues.For_All (Init);
   procedure Initialize is
   begin
      Handling_Event := 0;
      Threads.Initialize;
      Initialize_Queue (All_Tasks);
   end Initialize;

   -------------------------
   --  Do_For_Every_Task  --
   -------------------------

   --   generic
   --     with procedure P (Item: in Task_Ref);
   procedure Do_For_Every_Task is
      procedure Q is new Task_Queues.For_All (P);
   begin
      Q (All_Tasks);
   end Do_For_Every_Task;

   -----------------
   --  Start_Job  --
   -----------------

   procedure Start_Job (T : in out Task_Object) is
      Now : constant Time := Simulator.Current_Time;
   begin
      pragma Assert (not T.Pending_Jobs.Is_Empty);
      T.Current_Job := T.Pending_Jobs.Front_Of;
      T.Remaining_Exec_Time := T.Current_Job.Execution_Time;
      --  set up completion event in simulator
      Threads.New_Job (T.Thread, T.Current_Job);
      --  allows the scheduling policy
      --  to recompute T's priority, if necessary
      --  e.g., to the absolute deadline for simple EDF
      pragma Debug (Trace (3,
         Name (T) & "starts job that arrived at"
         & Time'Image (T.Current_Job.Arrival_Time)
         & " with execution time"
         & Time'Image (T.Current_Job.Execution_Time)));
   end Start_Job;

   ----------------
   --  Arrivals  --
   ----------------

   package body Job_Arrival_Events is

      procedure Handler (E : in out Object) is
         Now : constant Time := Simulator.Current_Time;
         J : Jobs.Job;
         Busy : Boolean;
      begin
         pragma Debug (Up (1, "Arrival"));
         pragma Assert (E = E.T.Arrival);
         pragma Assert (Now = E.Event_Time);
         --  get job parameters
         E.T.Model.Arrive
           (T => Now,
            J => J,
            Next_Arrival_Time => E.T.Arrival.Event_Time);
         --  set up next arrival in simulator
         Simulator.Schedule_Event (E.T.Arrival);
         --  make this task busy if job is arriving to an empty work queue
         Busy := not E.T.Pending_Jobs.Is_Empty;
         E.T.Pending_Jobs.Add (J);
         if not Busy then
            Start_Job (E.T.all);
            Threads.Unsuspend (E.T.Thread);
            Threads.Schedule;
         end if;
         pragma Debug (Down);
      end Handler;

      function Name (E : Object) return String is
      begin
         return Name (E.T.all)
           & "arrival " & Events.Object (E).Name;
      end Name;

   end Job_Arrival_Events;

   -------------------
   --  Completions  --
   -------------------

   package body Job_Completion_Events is

      procedure Handler (E : in out Object) is
         Now : constant Time := Simulator.Current_Time;
         RET : Time renames E.T.Remaining_Exec_Time;
         Elapsed_Time : Time;
      begin
         pragma Debug (Up (1, "Completion"));
         pragma Assert (E = E.T.Completion);
         --  update remaining execution time
         Elapsed_Time := Now - E.T.Last_Time_Check;
         RET := RET - Elapsed_Time;
         E.T.Last_Time_Check := Now;
         pragma Assert (RET = 0);
         --  track total time, for assertion-checking
         E.T.Total_Exec_Time :=
           E.T.Total_Exec_Time + Elapsed_Time;
         --  record statistics for this job
         Stats.End_Of_Job_Update
           (D => E.T.Stats_Data,
            RT => Now - E.T.Current_Job.Arrival_Time,
            Deadline => E.T.Current_Job.Absolute_Deadline,
            Exec_Time => E.T.Current_Job.Execution_Time,
            Now => Now);
         --  Remove it from the job queue.
         E.T.Pending_Jobs.Pop;
         if E.T.Pending_Jobs.Is_Empty then
            --  suspend this task if there are no more jobs
            Threads.Suspend (E.T.Thread);
         else
            --  otherwise, start the next job
            Start_Job (E.T.all);
            --  set up completion event in simulator
            E.T.Completion.Event_Time :=
              Now + E.T.Remaining_Exec_Time;
            Simulator.Schedule_Event (E.T.Completion);
         end if;
         Threads.Schedule;
         pragma Debug (Down);
      end Handler;

      function Name (E : Object) return String is
      begin
         return  Name (E.T.all) & "completion " & Events.Object (E).Name;
      end Name;

   end Job_Completion_Events;

   ---------------------
   --  Go Events  --
   ---------------------

   --  should not call Threads.Schedule, since
   --  these events are triggered by the thread
   --  scheduler

   package body Go_Events is

      procedure Handler (E : in out Object) is
         Now : constant Time := Simulator.Current_Time;
      begin
         pragma Debug (Up (2, "Go"));
         pragma Debug (Trace (3, Name (E)));
         pragma Assert (E = E.T.Go);
         pragma Assert (not E.T.Running);
         E.T.Running := True;
         E.T.Last_Time_Check := Now;
         --  set up completion event in simulator
         E.T.Completion.Event_Time :=
           Now + E.T.Remaining_Exec_Time;
         Simulator.Schedule_Event (E.T.Completion);
         pragma Debug (Down);
      end Handler;

      function Name (E : Object) return String is
      begin
         return Name (E.T.all) & "go " & Events.Object (E).Name;
      end Name;

   end Go_Events;

   ---------------------
   --  Stop Events  --
   ---------------------

   --  should not call Threads.Schedule, since
   --  these events are triggered by the thread
   --  scheduler

   package body Stop_Events is

      procedure Handler (E : in out Object) is
         Now : constant Time := Simulator.Current_Time;
         RET : Time renames E.T.Remaining_Exec_Time;
         Elapsed_Time : Time;
      begin
         pragma Debug (Up (2, "Stop"));
         pragma Debug (Trace (3, Name (E)));
         pragma Assert (E = E.T.Stop);
         pragma Assert (E.T.Running);
         E.T.Running := False;
         --  update remaining execution time
         Elapsed_Time := Now - E.T.Last_Time_Check;
         RET := RET - Elapsed_Time;
         E.T.Last_Time_Check := Now;
         --  track total time, for assertion-checking
         E.T.Total_Exec_Time :=
           E.T.Total_Exec_Time + Elapsed_Time;
         if RET > 0 then
            Simulator.Cancel_Event (E.T.Completion);
            --  Consider simultaneious suspension and
            --  completion events, where the suspension comes
            --  ahead of the completion.  In this case we
            --  want to allow the completion to be processed.
         end if;
         pragma Debug (Down);
      end Handler;

      function Name (E : Object) return String is
      begin
         return Name (E.T.all) & "stop " & Events.Object (E).Name;
      end Name;

   end Stop_Events;

   -----------------
   --  Get_Stats  --
   -----------------

   function Get_Stats (T : Task_Object) return Stats.Data is
   begin
      return T.Stats_Data;
   end Get_Stats;

   ------------
   --  Name  --
   ------------

   function Name (T : in Task_Object) return String is
   begin
      return Trim (T.Name, Right) & " ";
   end Name;

end Tasks;
@


1.6
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: tasks.adb,v 1.5 2008/11/23 01:54:28 baker Exp baker $
a250 3
         --  This is a good stopping point, so
         --  give simulator a chance to stop.
         Simulator.Check_Time;
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: tasks.adb,v 1.4 2008/11/21 23:10:36 baker Exp baker $
d96 4
a99 2
        (Max_Response_Time => 0,
         Total_Response_Time => 0,
d249 1
d359 1
a359 1
   function Get_Stats (T : Task_Ref) return Stats.Data is
@


1.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: tasks.adb,v 1.3 2008/11/20 22:18:50 baker Exp baker $
d33 3
a35 5
      pragma Debug (
         Debug (11,
            Integer'Image (Handling_Event) &
                  "->" & Integer'Image (Level) &
                  ' ' & Msg));
d42 1
a42 1
      pragma Debug (Debug (11, "<-"));
d64 1
a64 1
      T.Arrival.Ordinal := 5;
d82 4
a85 1
      All_Tasks.Add (T);
d123 2
a124 2
      T.Remaining_Execution_Time := 0;
      T.Total_Execution_Time := 0;
d130 1
d132 1
d142 1
d168 1
a168 1
      T.Remaining_Execution_Time := T.Current_Job.Execution_Time;
d174 2
a175 2
      pragma Debug (Debug (3,
         Name (T) & "starts job that arrived at "
d177 2
a178 3
         & " with execution time "
         & Time'Image (T.Current_Job.Execution_Time)
         & " (Now = " & Time'Image (Now) & ")"));
d216 1
a216 1
           & " arrival " & Events.Object (E).Name;
d229 1
a229 1
         RET : Time renames E.T.Remaining_Execution_Time;
d240 2
a241 2
         E.T.Total_Execution_Time :=
           E.T.Total_Execution_Time + Elapsed_Time;
d248 4
a251 1
         --  remove it from the job queue
d259 4
d289 1
a289 1
         pragma Debug (Debug (3, Name (E)));
d296 1
a296 1
           Now + E.T.Remaining_Execution_Time;
d320 1
a320 1
         RET : Time renames E.T.Remaining_Execution_Time;
d324 1
a324 1
         pragma Debug (Debug (3, Name (E)));
d333 2
a334 2
         E.T.Total_Execution_Time :=
           E.T.Total_Execution_Time + Elapsed_Time;
d367 1
a367 1
      return "task " & Trim (T.Name, Right) & " ";
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id: tasks.adb,v 1.2 2008/11/20 18:49:43 baker Exp baker $
d74 2
a75 1
      Move (Name, T.Name, Drop => Right, Justify => Left, Pad => ' ');
d212 2
a213 1
         return Name (E.T.all) & "arrival " & Events.Object (E).Name;
d314 1
d357 1
a357 1
      return "task " & T.Name;
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
--  $Id$
d34 1
a34 1
         Debug (7,
d36 2
a37 1
                   "->" & Integer'Image (Level) & Msg));
d44 1
a44 1
      pragma Debug (Debug (7, "<-"));
a60 1
      T.Arrival.Ordinal := 1;
d62 3
d66 6
a127 1
      Put_Line (Log, "--5--");
d188 1
a188 1
--         Up (1, "Arrival");
a196 1
         Put_Line (Log, "--6--");
d206 1
a206 1
--         Down;
d227 1
a227 1
--         Up (1, "Completion");
d253 1
a253 1
--         Down;
d276 1
a276 1
--         Up (2, "Go");
a284 1
         Put_Line (Log, "--7--");
d286 1
a286 1
--         Down;
d311 1
a311 1
--         Up (2, "Stop");
a322 1
            Put_Line (Log, "--2--");
d329 1
a329 1
--         Down;
@


1.1
log
@Initial revision
@
text
@d1 3
a3 1
With Simulator;
d5 5
d12 133
d151 1
d153 1
d155 5
a159 6
      T.Remaining_Execution_Time :=
         T.Current_Job.Execution_Time;
      T.Policy.Change_Job (T.Thread, T.Current_Job);
      --  call out to the scheduling policy
      --  to recompute T's priority, if necessary;
      --  should set T.Task_Priority
d161 6
a166 1
      --  and to the relabive deadline for Deadline Monotonic
d176 2
a177 3
         Now : Time := Simulator.Current_Time;
         J : Jobs.Object;
         T : Task_Ref := E.T;
d180 2
a181 1
         pragma Assert (E = T.Arrival);
d184 4
a187 3
         T.Model.Arrive (T => Now,
                         J => J,
                         Next_Arrival_Time => T.Arrival.Event_Time);
d189 2
a190 1
         Simulator.Schedule_Event (T.Arrival);
d192 2
a193 2
         Busy := not T.Pending_Jobs.Is_Empty;
         T.Pending_Jobs.Add (J);
d195 2
a196 1
            Start_Job (T.all);
d199 1
d204 1
a204 1
         return "arrival " & Events.Object (E).Name;
a208 21
   --------------------
   --  Complete Job  --
   --------------------

   procedure Complete_Job (T : in out Task_Object) is
      Now : Time := Simulator.Current_Time;
      RT : Time := Now - T.Current_Job.Arrival_Time;
   begin
      pragma Assert (not T.Pending_Jobs.Is_Empty);
      pragma Assert (T.Remaining_Execution_Time = 0);

      Stats.Update (T.Data, RT, T.Current_Job.Absolute_Deadline);

      T.Pending_Jobs.Pop;
      if T.Pending_Jobs.Is_Empty then
         Threads.Suspend (T.Thread);
      else
         Start_Job (T);
      end if;
   end Complete_Job;

d216 3
a218 2
         Now : Time := Simulator.Current_Time;
         T : Task_Ref := E.T;
d220 25
a244 3
         pragma Assert (E = T.Completion);
         pragma Assert (Now = E.Event_Time);
         Complete_Job (T.all);
d246 1
d251 1
a251 1
         return "completion " & Events.Object (E).Name;
d267 1
a267 2
         Now : Time := Simulator.Current_Time;
         T : Task_Ref := E.T;
d269 6
a274 3
         pragma Assert (E = T.Go_Event);
         pragma Assert (not T.Running);
         T.Last_Go_Time := Now;
d276 5
a280 3
         T.Completion.Event_Time :=
         Now + T.Remaining_Execution_Time;
         Simulator.Schedule_Event (T.Completion);
d285 1
a285 1
         return "go " & Events.Object (E).Name;
d301 2
a302 1
         Now : Time := Simulator.Current_Time;
a303 2
         T : Task_Ref := E.T;
         RET : Time renames T.Remaining_Execution_Time;
d305 6
a310 4
         pragma Assert (E = T.Stop_Event);
         pragma Assert (T.Running);
         Simulator.Cancel_Event (T.Completion);
         Elapsed_Time := Now - T.Last_Go_Time;
d312 11
a322 3
         pragma Assert (RET >= 0);
         if RET = 0 then
            Complete_Job (T.all);
d324 1
d329 1
a329 1
         return "stop " & Events.Object (E).Name;
a333 34
   ------------
   --  Init  --
   ------------

   procedure Init
     (T : in out Task_Object;
      M : Workload_Models.Class_Ref) is
      use Threads;
   begin
      T.Running := False;
      T.Data :=
        (Max_Response_Time => 0,
         Total_Response_Time => 0,
         Job_Count => 0,
         Missed_Deadlines => 0);
      T.Current_Job :=
        (Arrival_Time => 0,
         Execution_Time => 0,
         Absolute_Deadline => 0);
      T.Remaining_Execution_Time := 0;
      T.Pending_Jobs.Clear;
      if T.Thread = null then
         T.Thread := Threads.New_Thread
           (Policy => T.Policy,
            Parms => T.Parms,
            Go_Event => T.Go_Event'Unchecked_Access,
            Stop_Event => T.Stop_Event'Unchecked_Access,
            Name => T.Name);
      end if;
      T.Policy.Init (T.Thread);
      T.Arrival.Event_Time := T.Model.Start_Time;
      Simulator.Schedule_Event (T.Arrival);
   end Init;

d340 1
a340 1
      return T.Data;
@
